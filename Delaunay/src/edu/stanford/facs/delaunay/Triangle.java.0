/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package edu.stanford.facs.delaunay;

import edu.stanford.facs.drawing.FloatingPoint;
import java.awt.Polygon;
import java.awt.Point;
import javax.swing.tree.DefaultMutableTreeNode;

/**
 * $Id: Exp $
 * @author cate
 */
public class Triangle extends Polygon {
    private static int MAX=3;
    private Triangle[] daughters = new Triangle[MAX];
    private Circle circle;
    private static int A=0;
    private static int B=1;
    private static int C=2;
    private boolean LIVE = true;
    
    private int id;
    private FloatingPoint[] points = new FloatingPoint[MAX];
    private DefaultMutableTreeNode treeNode;
    
   

//
//    public Triangle (){
//      super ();
//    }

    public Triangle (int[]x, int[]y){
        super (x, y, 3);
        points[0] = new FloatingPoint (x[0], y[0]);
        points[1] = new FloatingPoint (x[1], y[1]);
        points[2] = new FloatingPoint (x[2], y[2]);
       
        id = points[A].hashCode() ^ points[B].hashCode() ^ points[C].hashCode();
//        System.out.println ("   --- new Triangle ------" + toString());
        circle = new Circle(this);
        treeNode = new DefaultMutableTreeNode (this);

    }
    public Triangle (float []xf, float[] yf){
        points[0] = new FloatingPoint (xf[0], yf[0]);
        points[1] = new FloatingPoint (xf[1], yf[1]);
        points[2] = new FloatingPoint (xf[2], yf[2]);
        id = points[A].hashCode() ^ points[B].hashCode() ^ points[C].hashCode();
        System.out.println ("   --- new Triangle ------");
        circle = new Circle(this);
        int order1 = points[A].hashCode() ^ points[C].hashCode() ^ points[B].hashCode();
//        System.out.println ("\t\t "+ id + " vs " + order1);
        treeNode = new DefaultMutableTreeNode (this);
        
    }
    
    public DefaultMutableTreeNode getTreeNode (){
        return treeNode;
    }

    

    public int getId() {
        return id;
    }

    public FloatingPoint[] getPoints() {
        return points;
    }

    public boolean containsVertex (FloatingPoint p){
        boolean flag = false;
        for (int i=0; i < npoints; i++){
            if (p.xf == points[i].xf && p.yf == points[i].yf){
                flag = true;
                break;
            }
        }
        return flag;
    }

   
    
    public void makeDaughters (FloatingPoint xx){
        int inorout = contains(xx);
        System.out.println (inorout + "  makeDaughters");
        if (inorout > 0){//perhaps this should be > 0.
            float [] x1= {xx.xf, points[0].xf, points[1].xf};
            float [] y1 = {xx.yf, points[0].yf, points[1].yf};
            daughters[0] = new Triangle (x1, y1);
            float[] x2={xx.xf, points[1].xf, points[2].xf};
            float[] y2 = {xx.yf, points[1].yf, points[2].yf};
            daughters[1] = new Triangle (x2, y2);
            float[] x3 = {xx.xf, points[2].xf, points[0].xf};
            float[] y3 = {xx.yf, points[2].yf, points[0].yf};
            daughters[2] = new Triangle (x3, y3);
        }
    }
    
    public void makeOneDaughter (Triangle tri) {

        if (daughters[0] != null){
            if (daughters[1] !=null){
               if (daughters[2] != null){
                   System.out.println ("Isn't this an error that there are no empty daughter cells?");
               }  
               else {
//                   daughters[2] = new Triangle (pts[A], pts[B], pts[C]);
                   daughters[2] = tri;
//                   daughters[2] = new Triangle (xs, ys);
//                   System.out.println ("(2) " + daughters[2].toString());
               }
            }
            else {
//                daughters[1] = new Triangle (pts[A], pts[B], pts[C]);
                daughters[1] = tri;
//                daughters[1] = new Triangle (xs, ys);
//                System.out.println ("(3) "+ daughters[1].toString());
            }
        }
        else {
//            daughters[0] = new Triangle (pts[A], pts[B], pts[C]);
            daughters[0] = tri;
//            daughters[0] = new Triangle (xs, ys);
//            System.out.println ("(0) " + daughters[0].toString());
        }
    }

    public int  contains (FloatingPoint p){
        
        int j;
        boolean flag = false;
       int ztest=0;
//       System.out.println ("------------- MY Contains ---------------------");
//       boolean isIn = mycontains (p);
        System.out.println (" -----------contains------------- ");
        for (int i=0; i < points.length; i++){
          j = (i+1) % 3;
//          System.out.println (i + ", "+ j);
//          System.out.println ("P: " + p.toString());
//          System.out.println ("Point i "+ points[i].toString());
//          System.out.println ("Point j "+ points[j].toString());
          float d =( points[j].xf -points[i].xf) * (p.yf - points[i].yf) -
                   ( points[j].yf -points[i].yf) * (p.xf - points[i].xf);
          System.out.println ("------  Value of d is " + d);
          if (d< 0.0) { 
//              System.out.println ("  d is less than 0 " +i + ", "+j);
              return -1;
          }
          else if ( d == 0){
              System.out.println (" contains d == 0");
              ztest = 1;
          }
          else if (d > 0){
              ztest = 1;
          }
          
        }
//System.out.print (" ztest = " + ztest);
//        if (ztest == 0 ){ 
//            ztest = 1;
//            flag = true;
//            
//        }
//        else if (ztest == 1){
//            ztest = 0;
//            flag = false;
//        }
        
    System.out.println ("  ztest is returning "+ ztest );           
        
        return ztest ;
    }
    
    private float determinant (FloatingPoint p1, FloatingPoint p2){
        float d=0;
        
        d = (p1.xf*p2.yf) - (p1.yf * p2.xf);
//        System.out.println (p1.toString() + ", "+ p2.toString()+ " "+ d);
        return d;
    }
    
    public boolean mycontains (FloatingPoint p){
        boolean isIn = false;
        float a, b;
        
        a = (determinant(p, points[2]) - determinant (points[0], points[2])) / (determinant (points[1], points[2]));
        
        b = -1 * (determinant (p, points[1])- determinant (points[0], points[1])) / determinant (points[1], points[2]);
        
        if ((a > 0 && b > 0) && (a+b < 1))
            isIn = true;
        
//        System.out.println (" My Contains "+ a + ", "+ b+ " "+ isIn);
        return isIn;
        
    }

    public void markLiveStatus (boolean status){
        
        LIVE = status;
    }

    public boolean getLiveStatus () {
        return LIVE;
    }

  /** public Triangle containingTriangle2 (FloatingPoint xx){
       Triangle tri = null;
       
       System.out.println ("  Containing Triangle 2 is being called.  Should it? this is doing a super() call");
       if (contains (xx.xf, xx.yf)){
           if (LIVE){
               tri = this;
           }
           else {
               for (int i=0; i < 3; i++){
                   if (daughters[i] != null)
                      tri = daughters[i].containingTriangle2 (xx);
                      if (tri != null)
                          break;
               }
           }
       }

       return tri;
   }**/

    public Triangle containingTriangle (FloatingPoint xx) {
        Triangle tri = null;
        Triangle dtri = null;
        boolean checking = true;

//        System.out.println ("Containing Triangle " + toString() + xx.x + ", " + xx.y);
        int f = contains (xx);
        if (f == 1){
      //  if ( contains (xx.xf, xx.yf)){
           tri = this;
//           System.out.println ("Tri containing " + toString());
           checking = true;
        }
        else {
            checking = false;
            return null;
        }

        int i=0;
        while (checking && i < MAX){
            if (daughters[i] != null){
                dtri = daughters[i].containingTriangle (xx);
                if (dtri != null){
//                    System.out.println ("Dtri containing " + dtri.toString());
                    checking=false;
                }
            }
            i++;
        }
        if (dtri == null)
           return tri;
        else
            return dtri;
    }
   
    public Triangle[] getDaughters() {
        return daughters;
    }

    public boolean equals (FloatingPoint a, FloatingPoint b, FloatingPoint c){
        boolean flag = false;
        int hashcode = a.hashCode()^b.hashCode()^c.hashCode();

        if (id == hashcode)
            flag = true;
        return flag;
    }

    @Override
     public String toString() {
        StringBuilder buf = new StringBuilder();
//        buf.append(id).append(" ").append(LIVE).append (" :: ");
        for (int i=0; i < points.length; i++){
            buf.append("(").append(points[i].xf).append(", ").append(points[i].yf).append (")  ::");
            
        }
        buf.append(LIVE);
//        buf.append (getLiveStatus());
        return buf.toString();
    }
    
    public String printForR() {
        String nl = System.getProperty ("line.sep");
        StringBuilder buf = new StringBuilder();
        if (LIVE){
        
            buf.append ("x").append(id).append("<- c(").append (points[0].xf);
            buf.append (",").append(points[1].xf).append(",");
            buf.append (points[2].xf).append(",").append (points[0].xf);
            buf.append(");\n");

            buf.append ("y").append(id).append("<- c(").append (points[0].yf);
            buf.append (",").append(points[1].yf).append(",");
            buf.append (points[2].yf).append(",").append (points[0].yf);
            buf.append(");\n");
        }
        
        return buf.toString();
        
    }

    public Circle getCircle() {
        if (circle == null){
            circle = new Circle(this);
        }
        return circle;
    }
    /**This is the circle that contains this Triangle
     *
     */
    public class Circle   {

        double radius;
        FloatingPoint center ;
        private Triangle mytri;


        Circle(Triangle mytri) {
            this.mytri = mytri;
            circumcircle();

        }
        
 
        private void circumcircle() {
        //xpoints, ypoints, npoints from triangle
            double a0, a1, c0, c1;
            a0 = mytri.points[0].xf - mytri.points[1].xf;
            a1 = mytri.points[0].yf - mytri.points[1].yf;
            c0 = mytri.points[2].xf - mytri.points[1].xf;
            c1 = mytri.points[2].yf - mytri.points[1].yf;
            
             
            double det = a0*c1-(c0*a1);
//            System.out.println ("Circumcircle " + mytri.toString());
           // double det = mytri.xpoints[A]*mytri.ypoints[C] - mytri.xpoints[C] * mytri.ypoints[A];
            if (det  == 0) {
                System.out.print ("exception colinear points " + mytri.points[A].xf+", "+ mytri.points[C].yf + ", ");
                System.out.println (mytri.points[C].xf + ", " +mytri.points[A].yf);
                return ;
            }
            det = 0.5/det;  
            double asq = a0 * a0 + a1 *a1;
            double csq = c0 * c0 + c1 * c1;
            double ctr0 = det * (asq*c1 - csq*a1);
            double ctr1 = det * (csq * a0 - asq*c0);
            radius =  Math.sqrt (ctr0*ctr0 + ctr1*ctr1);


            float xf =  (float) ctr0 + mytri.points[B].xf;
            float yf =  mytri.points[B].yf + (int) ctr1; // because of the weird display coordinates

            center = new FloatingPoint (xf,yf);
//            System.out.println ("Printing the radius and center of the circle " + radius + " ("+ xf + ", "+yf + ")");
        }

        public FloatingPoint getCenter(){
            return center;
        }
        public double getRadius() {
            return radius;
        }

    }


}
