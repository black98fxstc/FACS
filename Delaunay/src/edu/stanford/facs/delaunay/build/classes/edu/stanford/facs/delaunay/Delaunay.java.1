/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package edu.stanford.facs.delaunay;

import edu.stanford.facs.drawing.FloatingPoint;
import java.awt.event.ActionEvent;
import java.util.HashMap;
import edu.stanford.facs.drawing.DrawingFrame;
import edu.stanford.facs.logicle.Logicle;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Set;
import javax.swing.JTree;

/**
 * $Id: Exp $
 * @author cate
 */
public final class Delaunay implements ActionListener{

    private TriangleTree tree;
    private HashMap <Integer, FloatingPoint> lineHash = new HashMap<Integer, FloatingPoint>();
    private HashMap <Integer, Triangle> triangleHash = new HashMap<Integer, Triangle>();
    private DrawingFrame frame;
    private ArrayList<Triangle> triangleQueue = new ArrayList<Triangle>();
    private static int A=0;
    private static int B=1;
    private static int C=2;
    private int nextTask=0;
    private float[][] logicledata;
//    private float minx, miny, maxx, maxy;
    private static float bigscale= 2;
    private int nextPoint=0;
    private float[][] data;
    private FloatingPoint[] fpData;
    FloatingPoint[] boundingBox;
    private JTree jtree;
    


    /**
     * These hash tables.  lineHash :
     * for vertices A, B, C.  Get vertex A based on the hash key h(B) - h(C)
     * triangleHash:  The key for triangle is H(A) ^ H(B) ^ h(C)
     *
     */


    public Delaunay(DrawingFrame f) {

       this.frame = f;
       setUp();

    }
    
    
    public Delaunay (DrawingFrame f, float[][] data){
        System.out.println (data.length + "  " +data[0].length);
//        logicledata = transformToLogicle (data);
//        float[][] logdata = transformToLog (data);
      //  System.exit(1);
        frame = f;
        frame.addActionListener (this);
        this.data = data;
        
//        float[] xx = data[0];
//        Arrays.sort (xx);
//        System.out.println ("minx = " + xx[0] + "  maxx = "+ xx[xx.length-1]);
//        float minx = xx[0];
//        float maxx = xx[xx.length-1];
//        float[]yy = data[1];
//        Arrays.sort(yy);
//        float miny = yy[0];
//        float maxy = yy[yy.length-1];
//        System.out.println ("miny = " + yy[0] + "  maxy = "+ yy[yy.length-1]);
        
        float minx=10000000, maxx=0;
        float miny=10000000, maxy=0;
        for (int i=0; i < data.length; i++){
            if (data[i][0] < minx)minx=data[i][0];
            else if (data[i][0] > maxx) maxx = data[i][0];
            if (data[i][1] < minx) miny = data[i][1];
            else if (data[i][1] > maxy) maxy= data[i][1];
            
        }
        System.out.println ("minx = " + minx + "  maxx = "+ maxx);
        System.out.println ("miny = " + miny + "  maxy = "+ maxy);
        //create an artificial bounding box based on these values
        
//        frame.addTree (tree); //the frame does not need to know about the tree

        FloatingPoint[] trifp = createBoundingBox (minx, maxx, miny,  maxy);
        for (int i=0; i < trifp.length; i++){
            if (trifp[i].xf < minx) minx=trifp[i].xf;
            if (trifp[i].yf > maxx) maxx=trifp[i].xf;
            if (trifp[i].yf < miny) miny = trifp[i].yf;
            if (trifp[i].yf > maxy) maxy = trifp[i].yf;
        }
         frame.setDataMinMax(minx, miny, maxx, maxy);
         
        System.out.println ("  bounding box "+  trifp[0].toString()+ ","+trifp[1].toString()+ ", "+ trifp[2].toString());
        float[] xxx = {trifp[0].xf, trifp[1].xf, trifp[2].xf};
        float[] yyy = {trifp[0].yf, trifp[1].yf, trifp[2].yf};
        Triangle tri = new Triangle (xxx, yyy);
        frame.addJTree(tri.getTreeNode());
        
        
        this.tree = new TriangleTree(tri, frame, this);
      //  frame.setBoundingBox (tri);
        for (int i=0; i < trifp.length; i++){
            frame.addPoint (trifp[i]);
        }
        frame.addLine (trifp[0], trifp[1]);
        frame.addLine (trifp[1], trifp[2]);
        frame.addLine (trifp[2], trifp[0]);
        hashATriangle (tri);
//        float[][]mydata = new float[2][100];
//        Random random = new Random (3234567);
//        for (int i=0; i < 100; i++){
//            mydata[0][i] = random.nextFloat()*1000;
//            mydata[1][i] = random.nextFloat()*1000;
//        }
            
        processData(data, trifp);
//        printForR();

    }
//    public void nextPoint() {
//        
//    }


    private FloatingPoint[] createBoundingBox (float minx, float maxx, float miny, float maxy){
//        float bbminx=bigscale, bbminy=bigscale, bbmaxx=-1, bbmaxy=-1;
        System.out.println (" Create Bounding Box ("+ minx + ", "+ maxx + ") ("+ miny + ", "+ maxy+")");
        FloatingPoint[] boundingtri = new FloatingPoint[3];
        float delx = maxx - minx;
        float dely = maxy - miny;
        float x1 = (float)0.5 * (minx + maxx);
        float y1 = maxy + bigscale * dely;
        boundingtri[0] = new FloatingPoint (x1, maxy+ bigscale*dely );
        
        
        x1 = minx- (float)0.5*bigscale*delx;
        y1 = miny- (float)0.5*bigscale*dely;
        boundingtri[1] = new FloatingPoint (x1, y1);
        
        x1 = maxx + (float) 0.5*bigscale * delx;
        y1 = miny - (float) 0.5*bigscale * dely;
        boundingtri[2] = new FloatingPoint (x1, y1);
        
        System.out.println ("  Bounding Triangle ");
        for (int i=0; i < boundingtri.length; i++){
            System.out.println (boundingtri[i].toString());

        }

        return boundingtri;

    }
    /**
     * 
     * @param data
     * @param trifp  This is the bounding box. 
     */
    public void processData (float[][] data, FloatingPoint[]trifp) {
        boundingBox = trifp;
        tree.traverseTree();
        for (int i=0; i < 5; i++){
            
            FloatingPoint fp = new FloatingPoint (data[i][0], data[i][1]);
            System.out.println ("Point "+ i + ".  " + data[i][0] + ", "+ data[i][1] );
            System.out.println (fp.toString() + "  "+ fp.hashCode());
            addNewPoint (fp);
            
            frame.updateDisplay();
            tree.traverseTree();
         //   printTriangleHash();
//            try {
//            Thread.sleep(2000);
//            } catch (Exception e){}
        }
        System.out.println ("------------------  First five are finished ");
        nextPoint=5;
        
    }

    public float[][] transformToLogicle (float[][]data){
        float[][] logdata = new float[data.length][data[0].length];
        int T = 1<<18;
        double W=0.5;
        double M=4.5;
        double A=0;
        System.out.println (" ------------- tranformToLogicle-----------");
        Logicle logicle = new Logicle (T, W, M, A);
        for (int i=0; i < data.length; i++){
            for (int j=0; j < data[i].length; j++){
                logdata[i][j] = (float) logicle.scale(data[i][j]);
                //System.out.println (data[i][j] + "  " + logdata[i][j] );
            }
        }

        return logdata;
    }
    
    public float[][] transformToLog (float[][]data){
        float[][] logdata = new float[data.length][data[0].length];
        System.out.println (" ------------- tranformToLogi-----------");
        for (int i=0; i < data.length; i++){
             for (int j=0; j < data[i].length; j++){
                 logdata[i][j] = (float) Math.log(data[i][j]);
                // System.out.println (data[i][j] + "  "+ logdata[i][j]);
             }
             
        }
        return logdata;
    }

    public void addNewPoint (FloatingPoint pt){
        //find the containing triangle
//        FloatingPoint pt = new FloatingPoint(p.xf, p.yf);
   //     pt = frame.transformPoint(p);
        nextTask = 0;
        triangleQueue = null;
        triangleQueue = new ArrayList <Triangle>();
        Triangle containing = tree.containingTriangle (pt);
        if (containing == null){
            System.out.println ("Oh no -- There is no containing triangle.  "+ pt.toString());
            return;
        }
        //create 3 new triangles and queue them for testing
//        System.out.println (" containing triangle = " + containing.toString());
        containing.makeDaughters (pt);
        FloatingPoint[] cpt = containing.getPoints();
        frame.addPoint (pt);
        frame.addLine (pt, cpt[A] );
        frame.addLine (pt, cpt[B]);
        frame.addLine (pt, cpt[C]);
        Triangle[] daughters = containing.getDaughters();
        
        for (int i=0; i < daughters.length; i++){
            hashATriangle (daughters[i]);
            triangleQueue.add (daughters[i]);
            frame.addTreeNode (containing.getTreeNode(), daughters[i].getTreeNode());
            //dumpLineHash();
        }
//        dumpLineHash();

        //erase the old triangle
      //  Point[] conpts = containing.getPoints();
        //update the hash table
        Integer key = new Integer (containing.getId());
        if (triangleHash.containsKey(key)){
            Triangle t = triangleHash.get (key);//should be the same as the containg
            containing.markLiveStatus (false);
            t.markLiveStatus (false);
            System.out.println ("Live status in the hashtable " + t.getLiveStatus());
        }


        //while there are triangles to test
        while (nextTask < triangleQueue.size()){
            Triangle newone;
            Triangle newtwo;
            // look up the 4th point.  points[A] is this pt what we are testing against
            FloatingPoint fourth = null;
            Triangle testTri = triangleQueue.get(nextTask);
//            System.out.println (nextTask + ". testtri = " + testTri.toString());
            if (testTri.getLiveStatus() == false){
                System.out.println (" Skip this one.  " + testTri.toString());
                nextTask++;
                continue;
            }
            FloatingPoint[] testpts = testTri.getPoints();
//            Integer keypt = new Integer (testpts[B].hashCode() - testpts[C].hashCode());
            Integer keypt = makeHashCodeForLine (testpts[C], testpts[B]);
//            System.out.println ("Looking for this hashcode " +keypt);
            if (lineHash.containsKey (keypt)) {
                 fourth = lineHash.get (keypt);
                 System.out.println ("fourth point is " + ptToString (fourth));
                //calculate the distance
            // if necessary flip the edge
                if (testForDistance (fourth, testTri)){
                    //create two new triangles
//                    System.out.println (testTri.toString());
                    float[]xs = {testpts[A].xf, testpts[B].xf, fourth.xf};
                    float[]ys = {testpts[A].yf, testpts[B].yf, fourth.yf};
                    newone = new Triangle (xs, ys);
//                    System.out.println ("new one ? " + newone.toString());
                    hashATriangle (newone);
                    
                    float[]xs2={testpts[A].xf, fourth.xf, testpts[C].xf};
                    float[]ys2={testpts[A].yf, fourth.yf, testpts[C].yf};
                    newtwo = new Triangle (xs2, ys2);
//                    System.out.println ("new two ? " + newtwo.toString());

                    hashATriangle (newtwo);
                    
                    //this is already done in hashATriangle

                     frame.addLine (testpts[A], fourth);


                //erase the old one by setting the live status to false and other stuff
                  key = new Integer (testTri.getId());
System.out.println ("testTri " + testTri.toString() + "  "+ key);
                    if (triangleHash.containsKey(key)){
                        Triangle t = triangleHash.get (key);
                        System.out.println (t.toString() + " ---- " + testTri);
                        //check the queue?  Is there already one of these in the queue
                        //checkTheQueue (testTri, false);
                        t.markLiveStatus (false);
                        t.makeOneDaughter (newone);
                        t.makeOneDaughter (newtwo);
                    }
                  Triangle oldtriangle = getHashTriangle (testpts[B], fourth, testpts[C]);
   
                  if (oldtriangle != null) {
                      key = new Integer (oldtriangle.getId());
                      if (triangleHash.containsKey (key)){
                          Triangle t = triangleHash.get (key);
                          t.markLiveStatus (false);
                          System.out.println (t.toString() + " --- old triangle --- " + oldtriangle);
                          t.makeOneDaughter (newone);
                          frame.addTreeNode (t.getTreeNode(), newone.getTreeNode());
                          t.makeOneDaughter (newtwo);
                          frame.addTreeNode (t.getTreeNode(), newtwo.getTreeNode());

                          triangleHash.put(key, t);  //????
                      }
                  }
                   
                  
                //erase the line in both directions
                   removeLineFromHash (testpts[B], testpts[C]);
//                   frame.eraseLine (testpts[B], testpts[C]);


                //add two new triangles to the queue.
//                   System.out.println (" add to Queue one "+ newone.toString());
                   triangleQueue.add (newone);
//                  System.out.println (" add to Queue two "+ newtwo.toString());

                   triangleQueue.add (newtwo);
                }

                else {
                    System.out.println (" Distance is fine ");
                }
            }
            else {
                System.out.println ("There is no fourth point ");
            }
            System.out.println ("......... after one iteration of the queue ..........");
            nextTask++;
//            printQueue();

           // dumpLineHash();
//            System.out.println ("......"+ nextTask+ "................................................");
        }
//        printTriangleHash();
//        tree.printTree(tree.treeRoot);
    }

    private void checkTheQueue (Triangle tri, boolean live){
        System.out.println (" Check the queue " + tri.toString());
        for (int i=nextTask; i < triangleQueue.size(); i++){
            Triangle nextone = triangleQueue.get(i);
            System.out.println (i + ". " + nextone.toString());
            if (nextone.hashCode() == tri.hashCode())
                System.out.println (" do these two match ? "+ tri.toString() + "===="+ nextone.toString());
        }
    }
    
    private void printTriangleHash() {
        System.out.println ("----------------------printTriangleHash-----------------------");
        Set<Integer> keys = triangleHash.keySet();
        Iterator it = keys.iterator();
        while (it.hasNext()){
            Triangle tri = triangleHash.get ((Integer) it.next());
            System.out.println (tri.toString());

        }

    }
    
    public void printForR() {
        System.out.println("-----------Print for R-------------------");

        tree.printTreeForR (tree.treeRoot);
//        
//        Set<Integer> keys = triangleHash.keySet();
//        Iterator it = keys.iterator();
//        while (it.hasNext()){
//            Triangle tri = triangleHash.get ((Integer) it.next());
//            if (tri.getLiveStatus())
//                System.out.println (tri.printForR());
//
//        }
        
    }
    private void printQueue() {
        System.out.println (".........................................................");
        System.out.println ("..................Print Queue............................");

        for (int i=nextTask; i < triangleQueue.size(); i++){
            System.out.println (triangleQueue.get(i).toString());
        }
    }

     public final void hashATriangle(Triangle tri){
        Integer hint = new Integer (tri.getId());
        triangleHash.put (hint, tri);
        FloatingPoint[] points = tri.getPoints();
 System.out.print (" Hash a Triangle " +  ptToString (points[0]) + "  "+ ptToString(points[1]) + "  " + ptToString(points[2]));
 System.out.println ("  hashcode = " + hint);    
 Integer linehash = makeHashCodeForLine (points[A], points[B]);
        lineHash.put (linehash, points[C]);
        linehash = makeHashCodeForLine (points[B], points[C]);
        lineHash.put (linehash, points[A]);
        linehash = makeHashCodeForLine (points[C], points[A]);
        lineHash.put (linehash, points[B]);

    }

    private void setUp() {
     int[] x = {470, 10, 700};
        int[]y = {10, 540, 810};
        Triangle tri = new Triangle (x, y);
        tree = new TriangleTree(tri, frame, this);
    
        frame.addPoint (new FloatingPoint (470, 10));
        frame.addPoint (new FloatingPoint (10, 540));
        frame.addPoint (new FloatingPoint (700, 810));
        hashATriangle (tri);

        FloatingPoint[] pts = tri.getPoints();

        frame.addLine (pts[A], pts[B]);
        frame.addLine (pts[B], pts[C]);
        frame.addLine (pts[C], pts[A]);
       // dumpLineHash();

        FloatingPoint newpt = new FloatingPoint (370, 380);
        addNewPoint (newpt);
        frame.addPoint (newpt);
      //  dumpLineHash();
        newpt = new FloatingPoint (260,575);
        addNewPoint (newpt);
        frame.addPoint (newpt);
     //   dumpLineHash();
    }
    
   
    private void dumpLineHash () {
        System.out.println (" dump the line Hash ");
        Set<Integer> keys = lineHash.keySet();
        Iterator it = keys.iterator();
        while (it.hasNext()){
            Integer key = (Integer) it.next();
            System.out.print ("Key " + key);
            FloatingPoint pts = (FloatingPoint) lineHash.get (key);
            if (pts != null )
                System.out.println (" Hashed Line:  "+ ptToString(pts) );
            else
                System.out.println (" Not enough points in this line");

        }
    }

    private void dumpTriangleHash() {
System.out.println (" dump the triangle hash");
        Set<Integer> keys = triangleHash.keySet();
        Iterator it = keys.iterator();
        while (it.hasNext()){
            Integer key = (Integer) it.next();
//            System.out.print ("Key " + key);
            Triangle tri = (Triangle) triangleHash.get (key);
            if (tri != null) {
                System.out.println ("Hashed Triangle  "+ tri.toString());
            }
            else
                System.out.println (" No triangle");

        }

    }

    /* this point is the third in the triangle  */
    public FloatingPoint getLineHash (FloatingPoint a, FloatingPoint b){
        FloatingPoint point = null;
        Integer hashcode = new Integer (a.hashCode() - b.hashCode());

        if (lineHash.containsKey (hashcode)){
            point = lineHash.get (hashcode);
        }
        

        if (point != null)
            System.out.println ("The point for hashcode is " + hashcode+  " "+ ptToString(point));
        else
            System.out.println ("There is no point for this hashcode " + hashcode);
        return point;
        
    }

    public void removeLineFromHash (FloatingPoint a, FloatingPoint b){

        System.out.println ("..........removeLine from hash " + ptToString(a) + ","+ ptToString(b));
        System.out.println ("............................." + a.hashCode() + ", " + b.hashCode());
        int key = a.hashCode() - b.hashCode();

        Integer keyi = new Integer (key);
        if (lineHash.containsKey (keyi)){
           FloatingPoint p = lineHash.remove(keyi);
           System.out.println (key + "..... "+ ptToString(p));
            lineHash.remove (keyi);
            frame.eraseLine (a, b);
         
        }
        else
            System.out.println (" This key does not exist in the line hash " + keyi.toString());

        keyi = new Integer (b.hashCode() - a.hashCode());
        if (lineHash.containsKey (keyi)){

            FloatingPoint p = lineHash.remove (keyi);
            System.out.println (keyi.toString() + "........ "+ ptToString(p));
            frame.eraseLine (b, a);

        }
        else {
            System.out.println ("This key does not exist in the lineHash " + keyi.toString());
        }


    }

    /*
     * Test the radius of this triangle to the point.  Returns true
     * when the distance to the pt is less than the radius, thus
     * signaling the need to flip the edges.
     * positive is inside
     * 0 is on the line
     * negative is outside of the circle.
     */
    private boolean testForDistance (FloatingPoint pt, Triangle onetri){
        boolean flag= false;
        double radius = 0;
        double distance = 0.;
        double radd = 0.;
//        System.out.println (" testforDistance " + onetri.toString() + "  "+ ptToString (pt));
        FloatingPoint pointA = onetri.getPoints()[A];
        FloatingPoint b = onetri.getPoints()[B];
        FloatingPoint c = onetri.getPoints()[C];
       // Point fourth = getLineHash(c, b);
        if (pt != null){
            radius = onetri.getCircle().getRadius();
            FloatingPoint center = onetri.getCircle().getCenter();
            if (center == null){
                System.out.println ("  For some reason, this triangle has no center. " + onetri.toString());
                return false;
            }
            radd = (pt.xf - center.xf)*(pt.xf-center.xf)+ (pt.yf-center.yf)*(pt.y-center.yf);
            distance = radius*radius - radd;
//            double x2 = (pointA.x - pt.x)*(pointA.x - pt.x);
//            double y2 = (pointA.y - pt.y)*(pointA.y - pt.y);
//            distance = Math.sqrt (x2 + y2);
//            if (distance < radius)
//                flag = true;
            if (distance == 0){
                System.out.println ("Points are co-linear!!!");
            }
            if (distance > 0)
                flag = true;
        }
        System.out.println ("testForDistance "+ flag + " "+radius + " || "+ distance + " || " + radd);
        return flag;

    }

    private String ptToString(FloatingPoint pt) {
        String s = "("+pt.xf+","+pt.yf+")";
        return s;
    }

   

    public Triangle getHashTriangle (FloatingPoint a, FloatingPoint b, FloatingPoint c) {
        Triangle tri = null;
//        System.out.println ("getHashTriangle ");
        int hashcode = a.hashCode() ^ b.hashCode() ^ c.hashCode();
//        System.out.print ("GetHashTriangle Hashcode = " + hashcode + a.toString() + ", "+ b.toString() + ", " + c.toString());
        if (triangleHash.containsKey (new Integer (hashcode))){
            tri = triangleHash.get (new Integer (hashcode));
            if (tri != null)
                System.out.println ("  Found this triangle " + tri.toString());
        }
        return tri;
    }

    private Integer makeHashCodeForLine (FloatingPoint a, FloatingPoint b){
        int h = 0;

        h = a.hashCode() - b.hashCode();
        return new Integer (h);
    }

    public void actionPerformed (ActionEvent ae) {
        if (nextPoint >= data.length) {
            frame.zoomData(boundingBox);
            return;
        }
            
        FloatingPoint fp = new FloatingPoint (data[nextPoint][0], data[nextPoint][1]);
        
        nextPoint++;

      //  fp = frame.transformPoint(fp);
        System.out.println (" Process Next Point "+ fp.toString());
        frame.addPoint (fp);
        addNewPoint (fp);
        frame.updateDisplay();        
    }

    

}
